# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.18.0
# source: query.sql
import dataclasses
from typing import Any, AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from authors import models


COUNT_AUTHOR = """-- name: count_author \\:one
SELECT count(*) as author_count from authors
"""


DELETE_AUTHOR = """-- name: delete_author \\:exec
DELETE FROM authors
WHERE id = ?
"""


INSERT_AUTHOR = """-- name: insert_author \\:execresult
INSERT INTO authors
( 
    name
 ,  bio
 ,  address
 ,  date_of_birth
 ,  last_ts
 ,  savings_amt
 ,  loan_amt
 ,  disabled
 ,  married
 ,  payable
) VALUES (
    ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
)
"""


@dataclasses.dataclass()
class InsertAuthorParams:
    name: Any
    bio: Optional[Any]
    address: Optional[Any]
    date_of_birth: Optional[Any]
    last_ts: Optional[Any]
    savings_amt: Optional[Any]
    loan_amt: Optional[Any]
    disabled: Optional[Any]
    married: Optional[Any]
    payable: Optional[Any]


LIST_AUTHOR = """-- name: list_author \\:many
SELECT id, name, bio, address, date_of_birth, last_ts, savings_amt, loan_amt, disabled, married, payable FROM authors
WHERE id > ?
ORDER BY id
LIMIT 1000
"""


SELECT_AUTHOR = """-- name: select_author \\:one
SELECT
    id
 ,  name
 ,  bio
 ,  address
 ,  date_of_birth
 ,  last_ts
 ,  savings_amt
 ,  loan_amt
 ,  disabled
 ,  married
 ,  payable
FROM authors
WHERE id = ?
"""


UPDATE_AUTHOR = """-- name: update_author \\:exec
UPDATE authors
SET 
    name = ?
 ,  bio = ?
 ,  address = ?
 ,  date_of_birth = ?
 ,  last_ts = ?
 ,  savings_amt = ?
 ,  loan_amt = ?
 ,  disabled = ?
 ,  married = ?
 ,  payable = ?
WHERE id = ?
"""


@dataclasses.dataclass()
class UpdateAuthorParams:
    name: Any
    bio: Optional[Any]
    address: Optional[Any]
    date_of_birth: Optional[Any]
    last_ts: Optional[Any]
    savings_amt: Optional[Any]
    loan_amt: Optional[Any]
    disabled: Optional[Any]
    married: Optional[Any]
    payable: Optional[Any]
    id: Any


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def count_author(self) -> Optional[Any]:
        row = self._conn.execute(sqlalchemy.text(COUNT_AUTHOR)).first()
        if row is None:
            return None
        return row[0]

    def delete_author(self, *, id: Any) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_AUTHOR), {"p1": id})

    def insert_author(self, arg: InsertAuthorParams) -> sqlalchemy.engine.Result:
        return self._conn.execute(sqlalchemy.text(INSERT_AUTHOR), {
            "p1": arg.name,
            "p2": arg.bio,
            "p3": arg.address,
            "p4": arg.date_of_birth,
            "p5": arg.last_ts,
            "p6": arg.savings_amt,
            "p7": arg.loan_amt,
            "p8": arg.disabled,
            "p9": arg.married,
            "p10": arg.payable,
        })

    def list_author(self, *, id: Any) -> Iterator[models.Author]:
        result = self._conn.execute(sqlalchemy.text(LIST_AUTHOR), {"p1": id})
        for row in result:
            yield models.Author(
                id=row[0],
                name=row[1],
                bio=row[2],
                address=row[3],
                date_of_birth=row[4],
                last_ts=row[5],
                savings_amt=row[6],
                loan_amt=row[7],
                disabled=row[8],
                married=row[9],
                payable=row[10],
            )

    def select_author(self, *, id: Any) -> Optional[models.Author]:
        row = self._conn.execute(sqlalchemy.text(SELECT_AUTHOR), {"p1": id}).first()
        if row is None:
            return None
        return models.Author(
            id=row[0],
            name=row[1],
            bio=row[2],
            address=row[3],
            date_of_birth=row[4],
            last_ts=row[5],
            savings_amt=row[6],
            loan_amt=row[7],
            disabled=row[8],
            married=row[9],
            payable=row[10],
        )

    def update_author(self, arg: UpdateAuthorParams) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_AUTHOR), {
            "p1": arg.name,
            "p2": arg.bio,
            "p3": arg.address,
            "p4": arg.date_of_birth,
            "p5": arg.last_ts,
            "p6": arg.savings_amt,
            "p7": arg.loan_amt,
            "p8": arg.disabled,
            "p9": arg.married,
            "p10": arg.payable,
            "p11": arg.id,
        })


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_author(self) -> Optional[Any]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_AUTHOR))).first()
        if row is None:
            return None
        return row[0]

    async def delete_author(self, *, id: Any) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_AUTHOR), {"p1": id})

    async def insert_author(self, arg: InsertAuthorParams) -> sqlalchemy.engine.Result:
        return await self._conn.execute(sqlalchemy.text(INSERT_AUTHOR), {
            "p1": arg.name,
            "p2": arg.bio,
            "p3": arg.address,
            "p4": arg.date_of_birth,
            "p5": arg.last_ts,
            "p6": arg.savings_amt,
            "p7": arg.loan_amt,
            "p8": arg.disabled,
            "p9": arg.married,
            "p10": arg.payable,
        })

    async def list_author(self, *, id: Any) -> AsyncIterator[models.Author]:
        result = await self._conn.stream(sqlalchemy.text(LIST_AUTHOR), {"p1": id})
        async for row in result:
            yield models.Author(
                id=row[0],
                name=row[1],
                bio=row[2],
                address=row[3],
                date_of_birth=row[4],
                last_ts=row[5],
                savings_amt=row[6],
                loan_amt=row[7],
                disabled=row[8],
                married=row[9],
                payable=row[10],
            )

    async def select_author(self, *, id: Any) -> Optional[models.Author]:
        row = (await self._conn.execute(sqlalchemy.text(SELECT_AUTHOR), {"p1": id})).first()
        if row is None:
            return None
        return models.Author(
            id=row[0],
            name=row[1],
            bio=row[2],
            address=row[3],
            date_of_birth=row[4],
            last_ts=row[5],
            savings_amt=row[6],
            loan_amt=row[7],
            disabled=row[8],
            married=row[9],
            payable=row[10],
        )

    async def update_author(self, arg: UpdateAuthorParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_AUTHOR), {
            "p1": arg.name,
            "p2": arg.bio,
            "p3": arg.address,
            "p4": arg.date_of_birth,
            "p5": arg.last_ts,
            "p6": arg.savings_amt,
            "p7": arg.loan_amt,
            "p8": arg.disabled,
            "p9": arg.married,
            "p10": arg.payable,
            "p11": arg.id,
        })
