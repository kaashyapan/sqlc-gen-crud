// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package com.example.authors

import java.sql.Connection
import java.sql.SQLException
import java.sql.Statement
import java.sql.Timestamp
import java.time.Instant
import java.time.LocalDateTime

const val deleteAuthor = """-- name: deleteAuthor :exec
DELETE FROM authors
WHERE id = ?
"""

const val insertAuthor = """-- name: insertAuthor :execresult
INSERT INTO authors
( 
    name
 ,  bio
 ,  address
 ,  date_of_birth
 ,  last_ts
 ,  savings_amt
 ,  loan_amt
 ,  disabled
 ,  married
 ,  payable
) VALUES (
    ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
 ,  ?
)
"""

const val listAuthor = """-- name: listAuthor :many
SELECT id, name, bio, address, date_of_birth, last_ts, savings_amt, loan_amt, disabled, married, payable FROM authors
WHERE id > ?
ORDER BY id
LIMIT 1000
"""

const val selectAuthor = """-- name: selectAuthor :one
SELECT
    id
 ,  name
 ,  bio
 ,  address
 ,  date_of_birth
 ,  last_ts
 ,  savings_amt
 ,  loan_amt
 ,  disabled
 ,  married
 ,  payable
FROM authors
WHERE id = ?
"""

const val updateAuthor = """-- name: updateAuthor :exec
UPDATE authors
SET 
    name = ?
 ,  bio = ?
 ,  address = ?
 ,  date_of_birth = ?
 ,  last_ts = ?
 ,  savings_amt = ?
 ,  loan_amt = ?
 ,  disabled = ?
 ,  married = ?
 ,  payable = ?
WHERE id = ?
"""

class QueriesImpl(private val conn: Connection) : Queries {

// Delete one Author using id

  @Throws(SQLException::class)
  override fun deleteAuthor(id: Int) {
    conn.prepareStatement(deleteAuthor).use { stmt ->
      stmt.setInt(1, id)

      stmt.execute()
    }
  }

// Insert one row of Author

  @Throws(SQLException::class)
  override fun insertAuthor(
      name: String,
      bio: String?,
      address: String?,
      dateOfBirth: LocalDateTime?,
      lastTs: Instant?,
      savingsAmt: Double?,
      loanAmt: String?,
      disabled: Boolean?,
      married: Boolean?,
      payable: String?): Long {
    return conn.prepareStatement(insertAuthor, Statement.RETURN_GENERATED_KEYS).use { stmt ->
      stmt.setString(1, name)
          stmt.setString(2, bio)
          stmt.setString(3, address)
          stmt.setObject(4, dateOfBirth)
          stmt.setTimestamp(5, Timestamp.from(lastTs))
          stmt.setDouble(6, savingsAmt)
          stmt.setString(7, loanAmt)
          stmt.setBoolean(8, disabled)
          stmt.setBoolean(9, married)
          stmt.setString(10, payable)

      stmt.execute()

      val results = stmt.generatedKeys
      if (!results.next()) {
          throw SQLException("no generated key returned")
      }
	  results.getLong(1)
    }
  }

// Lists 1000 Author having id > ?

  @Throws(SQLException::class)
  override fun listAuthor(id: Int): List<Author> {
    return conn.prepareStatement(listAuthor).use { stmt ->
      stmt.setInt(1, id)

      val results = stmt.executeQuery()
      val ret = mutableListOf<Author>()
      while (results.next()) {
          ret.add(Author(
                results.getInt(1),
                results.getString(2),
                results.getString(3),
                results.getString(4),
                results.getObject(5, LocalDateTime::class.java),
                results.getTimestamp(6).toInstant(),
                results.getDouble(7),
                results.getString(8),
                results.getBoolean(9),
                results.getBoolean(10),
                results.getString(11)
            ))
      }
      ret
    }
  }

// Select one Author using id

  @Throws(SQLException::class)
  override fun selectAuthor(id: Int): Author? {
    return conn.prepareStatement(selectAuthor).use { stmt ->
      stmt.setInt(1, id)

      val results = stmt.executeQuery()
      if (!results.next()) {
        return null
      }
      val ret = Author(
                results.getInt(1),
                results.getString(2),
                results.getString(3),
                results.getString(4),
                results.getObject(5, LocalDateTime::class.java),
                results.getTimestamp(6).toInstant(),
                results.getDouble(7),
                results.getString(8),
                results.getBoolean(9),
                results.getBoolean(10),
                results.getString(11)
            )
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }

// Update one row of Author using id

  @Throws(SQLException::class)
  override fun updateAuthor(
      name: String,
      bio: String?,
      address: String?,
      dateOfBirth: LocalDateTime?,
      lastTs: Instant?,
      savingsAmt: Double?,
      loanAmt: String?,
      disabled: Boolean?,
      married: Boolean?,
      payable: String?,
      id: Int) {
    conn.prepareStatement(updateAuthor).use { stmt ->
      stmt.setString(1, name)
          stmt.setString(2, bio)
          stmt.setString(3, address)
          stmt.setObject(4, dateOfBirth)
          stmt.setTimestamp(5, Timestamp.from(lastTs))
          stmt.setDouble(6, savingsAmt)
          stmt.setString(7, loanAmt)
          stmt.setBoolean(8, disabled)
          stmt.setBoolean(9, married)
          stmt.setString(10, payable)
          stmt.setInt(11, id)

      stmt.execute()
    }
  }

}

